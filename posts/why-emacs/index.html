<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-05-19 Wed 20:30 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>/nebhrajani/posts/why-emacs/</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Nebhrajani A.V." />
<html class="sea-theme">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../stylesheets/hack.css" />
<link rel="stylesheet" href="../../stylesheets/css.css" />
<link rel="stylesheet" href="../../stylesheets/standard.css" />
<link rel="stylesheet" href="../../stylesheets/index.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<nav class="sidebar-nav">
<a class="nav-item" title="" href="https://nebhrajani-a.github.io/">home</a>
<a class="nav-item" title="" href="https://nebhrajani-a.github.io/posts/">posts</a>
<a class="nav-item" title="" href="https://nebhrajani-a.github.io/files/">files</a>
</nav>

<h1 id="title">Why Emacs?</h1>
<div class="post-meta"> <2021-04-30 Fri>   - 17 min read
</div>

<p>
For anybody who spends a large part of their day talking to a
computer, the dynamics of this interaction become incredibly
important: everything from posture to software tools. This isn't
something specific to programmers. In many cultures, swordsmen were
taught that mastery is achieved when the sword feels like an extension
of the body. Or, if you're looking for something more modern, see
Harry Potter's search for the 'just right' wand when he first visited
Diagon Alley.
</p>

<p>
The perfect marriage between a tool and its wielder involves only two
things:
</p>

<ul class="org-ul">
<li>The skill of the wielder, and</li>
<li>The qualities of the tool.</li>
</ul>

<p>
In general, the former takes an incredible amount of effort, so most
people who are learning an art seriously focus far more on it. This
leaves the latter to be discussed only by either the posers who assume
that buying the same golf club Tiger Woods uses gives them the same
level of skill, or the designers of the tool themselves. All is well
and good with the world.
</p>

<p>
For the moment, consider the case of a blacksmith making a perfect
hammer for himself. In this case, the blacksmith is both the wielder
and the designer of the tool, meaning that he can design this tool to
be <i>precisely</i> right for him. Unlike the general designer of a hammer,
he doesn't have to worry about whether the tool is good for ten
thousand people, and unlike the general wielder, he can build the tool
to work around his own inadequacies in skill.
</p>

<p>
A programmer using a program to accomplish a task is in <i>precisely</i>
the same position as this blacksmith. He has the skills to forge his
own tool, to make something perfectly suited to himself. Why doesn't
this happen then?
</p>

<p>
Well, duplicated effort, low quality, and low return on investment.
If everybody wrote their own web browser, the end result would be a
bunch of really bad programs and a huge time loss for all parties
involved. Everybody compromises a little bit to have a few stable,
large projects with features everyone wants, and possibly, a few
plugins for people to change the behaviour slightly, to taste.
Of course, these plugins don't provide a feature \(X\) as well as
the program having it natively, but oh well, such is life. Everybody
needs to compromise a little, and anyway, people have better things
to do than fight with an ugly plugin API.
</p>

<p>
However, I posit that what these large programs get right is that a
central base with sensible defaults and simple features is useful &#x2014;
however, their method of providing customisation to the user (a plugin
interface or something of the sort) isn't an instance of good design
in the special case where your user (wielder) base is mostly
programmers.
</p>

<p>
In this article, we explore what goes into making a really good text
editor, and why that editor is Emacs.
</p>


<div id="outline-container-orgec527ca" class="outline-2">
<h2 id="orgec527ca"><span class="section-number-2">1</span> Text Editors in History</h2>
<div class="outline-text-2" id="text-1">
<p>
A program that is able to open a file from disk, change a few
characters, and write it back to disk, is a text editor. This is a
deceptively simple description &#x2014; indeed, UNIX's <code>ed</code>, a line
editor, fulfills all these criteria. Programmers use text editors to
edit files called programs, that are written in human-readable
languages. Sometimes, programmers have to write in English as well.
This is when text editors with extra features become more useful &#x2014;
things like:
</p>

<ul class="org-ul">
<li>Visual mode: Instead of being able to only edit a line (or other
unit) at a time, the whole file can be viewed in a sort of
'buffer' and moved around in.</li>
<li>Better movement: Moving around faster over walls of text.</li>
<li>Syntax and spell checking: Tells the programmer where errors are
and makes them easy to correct.</li>
<li>Syntax highlighting: certain keywords are highlighted in different
colors to make reading easier.</li>
<li>Multiple files open at the same time.</li>
<li>Support for a bunch of different languages, scripts, and locales.</li>
<li>\(\cdots\)</li>
</ul>

<p>
Sometimes, even features like debuggers and version control systems
are integrated into text editors, creating what is called an
Integrated Development Environment (IDE).<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
I'm sure you'll now see the parallel with web browsers. Different
people want different things from text editors, and instead of
writing their own editors, people compromise a little and use a text
editor with sensible defaults. However, the big difference between
the two cases is the user base &#x2014; rather than the casual computer
user, the user base for programming-y text editors is programmers.
There must be a better way to reconcile the stability of a large,
popular project with the level of customisation and access
programmers can utilize to make the tool better, rather than an ugly
plugin system.
</p>
</div>

<div id="outline-container-org3e5f92c" class="outline-3">
<h3 id="org3e5f92c"><span class="section-number-3">1.1</span> Notable Text Editors</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The following are some of the text editors we'll discuss in this
post. If I missed your favourite text editor, forgive me, this page
has limited space. Text editors that can be run in the terminal are
written with their command names (like <code>vi</code>).
</p>

<ol class="org-ol">
<li><code>ed</code>: UNIX's original line text editor, also a part of the POSIX
standard. Nobody really uses it as a full time editor anymore.</li>
<li><code>vi</code>: A screen editor, modal in nature. Default on all
POSIX-compliant systems, so it's worth learning.</li>
<li><code>vim</code>: A port of <code>vi</code> with many extensions. Extremely widely
used. Many *nix systems actually run vim when the user calls
<code>vi</code>. Have a major war with <code>emacs</code> users.</li>
<li><code>nano</code>: A simple, Notepad-like editor for the terminal.</li>
<li><code>emacs</code>: The other big UNIX editor, focused on extensibility.
GNU Emacs is the most widely used fork. Have a major war with
<code>vi</code> / <code>vim</code> users.</li>
<li>Notepad and its clones: Simple GUI-only text editors. Can't do
much with these.</li>
<li>Sublime Text: An editor that was very popular a few years ago.
Python-based plugin API for customisation.</li>
<li>Atom: An editor developed by GitHub, designed to be 'hackable'.
Extension and package creation language: JavaScript, since it
ran on top of a web browser (Electron framework).</li>
<li>Visual Studio Code: Currently the most popular editor in the
world. Runs on top of a web browser (Electron), and uses
JavaScript for extension.</li>
</ol>

<p>
Now, instead of discussing these one by one, we'll pick up certain
common design principles between these editors and reason about
which ones are desirable.
</p>
</div>
</div>

<div id="outline-container-orgb4db604" class="outline-3">
<h3 id="orgb4db604"><span class="section-number-3">1.2</span> Platforms</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Generally, editors are written as a single big program (often in C),
that has all editor features and functions, and is compiled and
distributed. <code>vi</code>, <code>nano</code>, <code>vim</code>, and a few others follow this simple
model.
</p>

<p>
An alternative to this model is what many modern text editors (and in
fact many other applications do), is implement a browser core and
rendering engine, then write an application on top of it using
JavaScript or some other web technology. This has the tremendous
advantage of having a powerful scripting language that can be used to
change application properties on the fly. It also means that the same
application can be run as a web application hosted on some website. VS
Code and Atom use this model.
</p>

<p>
The final alternative is to implement a core that’s actually an
interpreter for a scripting language which is used to program an
editor. This is similar to the web browser model in that the
application properties can be changed on the fly, but different in
that the core doesn’t have to be as heavy and complicated as web
browsers. The core can be lightweight, run without a GUI, and most
importantly, doesn’t have to be in JavaScript and limited by what the
web standard may or may not allow. This is <code>emacs</code>' model.
</p>

<p>
An ideal editor uses the core and extension language model, because
this maximises extensibility without the explicit need for a plugin
interface or (God forbid) recompilation.
</p>
</div>
</div>

<div id="outline-container-orga458e37" class="outline-3">
<h3 id="orga458e37"><span class="section-number-3">1.3</span> Interfaces</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Editors can be TUI-only (<code>nano</code>), GUI-only (Atom, VS Code), or both.
TUI-only editors tend to not have fancy icons and support for certain
fonts and symbols, while GUI-only editors are useless on a system that
only provides a terminal interface.
</p>

<p>
A good editor provides both without any loss of feature in either,
beyond actual limitations enforced by a terminal. <code>emacs</code> does this.
<code>vim</code> has a GUI, but it’s a different program called <code>gvim</code>. Most
modern editors only have GUI support.
</p>
</div>
</div>

<div id="outline-container-org4b7a33b" class="outline-3">
<h3 id="org4b7a33b"><span class="section-number-3">1.4</span> Keyboard or Mouse-Driven</h3>
<div class="outline-text-3" id="text-1-4">
<p>
This is an interesting topic. Some editor interfaces are very
clicky. This means that to get something done, you often have to
click an icon or drag something from here to there. Naturally,
since mice are a GUI luxury, most TUI supporting editors have only
optional use of the mouse when running as a GUI.
</p>

<p>
However, this design choice is a little more complex. As any
seasoned computer user knows, keyboards are the fastest and most
precise way to interact with a computer. Hollywood understands
this too: the master hacker is always typing, since that is the
fastest way to talk to a computer when the world is going to be
blown up in three minutes. Even if you aren't in a Bond film,
there is more comfort associated with not having to reach for the
mouse and squint at tiny icons while editing. Moreover, keyboards
are more precise: consider mouse-based vs. keyboard-based
selection. Mice aren't a very useful tool for text editing, but
are indispensable in applications like photo editing.
</p>

<p>
Good editors, however, don't force this choices on users,
especially towards the mouse side, since that slows experienced
users down at the cost of newbie-friendliness. There should at
least be a way to do a mouse action using a keyboard.
</p>
</div>
</div>

<div id="outline-container-orga5670fe" class="outline-3">
<h3 id="orga5670fe"><span class="section-number-3">1.5</span> Complexity</h3>
<div class="outline-text-3" id="text-1-5">
<p>
This is one of the <i>really</i> big debates, which draws its roots from
the modular *NIX vs. monolithic Windows philosophy. In short,
proponents of simple editors claim that an editor is just another tool
among many others. An editor need not have regular expression
abilities: there’s <code>grep</code> for that. An editor need not have a
graphical debugger: what’s <code>gdb</code> for? This side uses the operating
system as the development environment, and oppose the unholy mixing of
these functions into a gigantic text editing program. [UNIX AS IDE]
</p>

<p>
The other side of the debate claims that having all these tools within
one environment makes the development process faster, since there is
very little context switching involved. Moreover, having a single
powerful tool allows interesting interfaces between functions that
would otherwise have been discrete and impossible to link together via
a text stream.
</p>

<p>
Today, it seems the monolithic side has <i>de facto</i> won, since even
editors like <code>vi</code> / <code>vim</code>, which pride themselves on simplicity:
</p>

<blockquote>
<p>
A student enquired of Master Wq, “When will I know I have mastered Vimscript?”
</p>

<p>
Master Wq answered, “When you never use it.”
</p>
</blockquote>

<p>
have extensions for file browsing and auto-completion. It’s just too
convenient not to have.
</p>
</div>
</div>

<div id="outline-container-org2c581a6" class="outline-3">
<h3 id="org2c581a6"><span class="section-number-3">1.6</span> Modal vs. Non-Modal</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Mos people today are entirely unfamiliar with modal editing as a
concept, since nearly no text editing programs have a modal
interface. A modal interface simply means that the editor has a
'normal' mode where pressing the key <code>a</code> (for instance) does not
insert the letter 'a', but instead performs some editor function.
To actually insert the letter, the editor must be put into 'insert'
mode, which is when pressing keys is a literal insert into the
file.
</p>

<p>
Modal interfaces may sound complicated, but, in truth, it's exactly
the same concept as a modifier key. When you hold down <code>Ctrl</code>, the
keyboard keys all behave differently. In this state, pressing 'f'
may execute the search function. Modal editing can simply be
thought of as putting the editor into a mode where a modifier key
is always pressed, or into a mode where you can just insert text. If
this sounds needlessly complicated, hang in there, we'll get to
discussing why it can actually be useful eventually.
</p>

<p>
For now, it is sufficient to note that the most popular modal
editor is <code>vi</code>, whose modal keybindings are so popular that nearly
every other editor has a way to use them, often as a plugin. The
quality of these plugins varies, and most are missing features
vital to the seasoned <code>vi</code> user.
</p>
</div>
</div>

<div id="outline-container-org2288130" class="outline-3">
<h3 id="org2288130"><span class="section-number-3">1.7</span> Extensibility</h3>
<div class="outline-text-3" id="text-1-7">
<p>
And now, to the elephant in the room. How much should a user be
able to change? How much should a user actually change?
</p>

<p>
In my opinion, a user of a text editor should never be bound by the
imagination of the program's author. This means that a user should
be able to use the editor to do things the author didn't even know
were possible, without editing the actual program binary. This is
especially important for text editors because people come up with
new features all the time, most of which are useful. This level of
extensibility requires an extension language.
</p>
</div>

<div id="outline-container-org100d459" class="outline-4">
<h4 id="org100d459"><span class="section-number-4">1.7.1</span> Extension Language</h4>
<div class="outline-text-4" id="text-1-7-1">
<p>
The definition of an extension language for a text editor isn't
well defined. In practice, they range from configuration files which
switch certain options on and off to Turing complete dialects of
Lisp, with most falling in between.
</p>
</div>
</div>

<div id="outline-container-orgfc9c511" class="outline-4">
<h4 id="orgfc9c511"><span class="section-number-4">1.7.2</span> Packages</h4>
</div>
<div id="outline-container-orgd4a5dcd" class="outline-4">
<h4 id="orgd4a5dcd"><span class="section-number-4">1.7.3</span> How Much Extension is Too Much?</h4>
<div class="outline-text-4" id="text-1-7-3">
<p>
 It should be obvious by now that there seem to be two important
'parts' of a text editing experience: the actual editing of text
(moving around, deleting text, etc.), and the environment setup: the
pane management, file management, version control and debugger
interfaces, etc. It should be obvious that most IDEs get the second
part fairly correct (usually for a specific language), but they
absolutely suck at raw text editing. We now examine these issues
separately, trying to pick the best of the lot in each case.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org3369667" class="outline-2">
<h2 id="org3369667"><span class="section-number-2">2</span> Raw Text Editing</h2>
<div class="outline-text-2" id="text-2">
<p>
Broadly speaking, all editors can be divided into two categories on
the basis of raw text editing: modal and non-modal. Most people are
familiar with non-modal editing: when whatever keys you hit on the
keyboard are typed directly. If you want to call an editor function,
you hold a modifier key (like <code>Ctrl</code>), and the keyboard is
transformed into an editor function interface. Powerful editors with
a lot of functions, like Emacs, rely heavily on modifier keys. In
fact, Emacs uses both <code>Ctrl</code> and <code>Meta</code> (or <code>Alt</code>) to call editor
functions. These are often chained together to create incredibly
long bindings that'll knot your pinkies up. However, they do give
access to a lot of powerful Emacs functions right from the keyboard.
Let's call this style of editing 'key chord' based editing (to steal
a metaphor from music theory): wherein multiple keys are pressed
simultaneously to call editor functions. In fact, in Emacs, going to
the next line is done using <code>C-n</code><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>, which calls the editor
function <code>next-line</code>. <code>next-line</code> is also bound to the down arrow
key.
</p>

<p>
The polar opposite of non-modal (key chord) editing is modal or key
note-style editing. We observe that while editing text, we either:
</p>
<ul class="org-ul">
<li>Insert text.</li>
<li>Select text.</li>
<li>Call some editor function.</li>
</ul>
<p>
That's it. vim's modal system is based on this principle: that
only three main modes are really needed: an 'insert' mode in which
typing letters inserts them literally, a 'visual selection' mode
where a region is highlighted and can then be operated upon, and a
'normal' mode from which all editor functions are available, called
by typing any key. In our previous discussion, we said modal editing
can be thought of as the normal mode being one where a modifier key
is always pressed. In vim's normal mode, pressing the key 'j' goes
to the next line. No modifiers: you just play notes on the keyboard.
</p>

<p>
Now, it's easy to superficially argue that although key chords are
sometimes painful to type, they're far simpler than having a modal
editor wherein you have to keep track of which mode you're in.
However, I posit that modal editing, and specifically vim's modal
editing, is actually a far superior paradigm. Let's see why.
</p>
</div>

<div id="outline-container-org5c6f64f" class="outline-3">
<h3 id="org5c6f64f"><span class="section-number-3">2.1</span> Home Row Keys</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Back when <code>vi</code> was written, it didn't have the luxury of assuming
that all keyboards had modifier keys, or that they had exactly the
same modifier keys as the ones on some other keyboard.
Standardisation hadn't taken place yet. This also meant that all
the editor's power had to be available using keys that'd definitely
be on most keyboards: alphanumeric and punctuation. These keys are
also located on the 'home row' of all keyboards, meaning you don't
have to move your hands much for commands that could be very
different from each other.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>



<div class="figure">
<p><img src="./11.png" alt="11.png" />
</p>
</div>

<p>
This also means no more Emacs pinky from hand gymnastics to press
multiple keys at the same time.
</p>
</div>
</div>

<div id="outline-container-org364da08" class="outline-3">
<h3 id="org364da08"><span class="section-number-3">2.2</span> Composability</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Vim's keybindings form a grammar within themselves. To understand
this, consider a few examples.
</p>

<ul class="org-ul">
<li><b>Move 10 Lines Down</b>
We know that <code>j</code> in normal mode moves the cursor down by a line.
<code>10j</code> will move the cursor ten lines down.</li>
<li><p>
<b>Move 4 Characters Back</b>
Press <code>4h</code> in normal mode. Note that in normal mode:
</p>
<ul class="org-ul">
<li><code>h</code> is move one character back,</li>
<li><code>l</code> is move one character forward,</li>
<li><code>j</code> is move one line down,</li>
<li><code>k</code> is move one line up.</li>
</ul>
<p>
Any vim command can be prefixed with a number \(n\) to do it \(n\) times.
</p></li>
<li><b>Move 3 Words Forward</b>
A 'word' is a space-separated group of letters. To move forward by
a word, press <code>w</code> in normal mode. To move back by a word, press
<code>b</code>. To move forward 3 vim words, press <code>3w</code>.</li>
<li><b>Delete 3 Back-words</b>
<code>d3b</code>.</li>
</ul>

<p>
This illustrates the power of vim's normal mode. It gives us
super-powerful text editing capabilities, and we've only covered the
very basics. Vim has a <b>action-count-object</b> model for composing
commands, where:
</p>
<ul class="org-ul">
<li><b>action</b> is what to do to the object. (Ex. <code>d</code>)</li>
<li><b>count</b> is the number of objects to do action on. (Ex. <code>3</code>)</li>
<li><b>object</b> is the unit to do action on. (Ex. <code>w</code>)</li>
</ul>
</div>
</div>

<div id="outline-container-orgb589e36" class="outline-3">
<h3 id="orgb589e36"><span class="section-number-3">2.3</span> Mnemonics</h3>
<div class="outline-text-3" id="text-2-3">
<p>
To get into insert mode, press <code>i</code>. To get into visual selection
mode, press <code>v</code>. Go back to normal mode? <code>Escape</code>. To paste, press
<code>p</code>. Delete? Press <code>d</code>. Undo? <code>u</code>. Copy/yank? <code>y</code>.
</p>

<p>
Even better, when combined with each other, these mnemonics hold:
delete a word is: <code>daw</code>, change 5 words is <code>c5w</code>, transpose two
characters is <code>xp</code>, and so on. (<code>x</code> is equivalent to <code>dl</code>, or
deleting a single character. Unlike <code>d</code>, <code>x</code> doesn't expect an
object to act on.)
</p>
</div>
</div>

<div id="outline-container-org3b26a40" class="outline-3">
<h3 id="org3b26a40"><span class="section-number-3">2.4</span> Speed</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Clearly, this makes editing text fast and easy to do. Moreover,
many commands are provided for speed: <code>0</code> goes to start of line,
<code>$</code> goes to end of line. <code>gg</code> goes to the first character of the
file, <code>G</code> goes to the last. <code>10G</code> goes to line 10. <code>dd</code> deletes the
current line, <code>yy</code> copies it. <code>fR</code> goes to the next occurrence of
the character 'R'. Capitalisation of many commands causes them to
act backwards: <code>FR</code> goes to the previous occurrence of <code>R</code>. All of
these, of course, can be composed. <code>di)</code> deletes all text within
the current parentheses.
</p>

<p>
It should be obvious by now that vim's way of editing text is fast
and intuitive, and fully justifies having different modes.
</p>
</div>
</div>

<div id="outline-container-orgbdf02a2" class="outline-3">
<h3 id="orgbdf02a2"><span class="section-number-3">2.5</span> Other Good Ideas in Vim</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Many of the following ideas are also implemented in Emacs, but few
other editors have such powerful implementations.
</p>
</div>

<div id="outline-container-org87296b4" class="outline-4">
<h4 id="org87296b4"><span class="section-number-4">2.5.1</span> Registers</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
Almost every operating system has a clipboard, a temporary space
where copied text is held until it's pasted. The problem with a
single clipboard, that I'm sure you've experienced, is copying
some other text overwrites the previous contents of the clipboard.
Ugh.
</p>

<p>
A register is precisely like a clipboard in that it's a temporary
place to hold textual data. However, here's the cool part: vim
provides around 10 default registers, and 26 registers reserved
for the user. Register <code>0</code> is the clipboard. Registers <code>1 to 9</code>
are effectively a clipboard history stack: eliminating the
overwrite problem with 9 layers of redundancy. Registers <code>a-z</code> are
for the user to write to and read from.
</p>

<p>
Using registers is incredibly easy: <code>"ay</code> writes to register <code>a</code>,
and <code>"ap</code> pastes its contents. There are some more advanced ways
to use registers as well, including appending to them and treating
them as macros.
</p>
</div>
</div>

<div id="outline-container-org5beb3ec" class="outline-4">
<h4 id="org5beb3ec"><span class="section-number-4">2.5.2</span> Macros</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
Let's say we have the following C program:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #5EC4FF; font-weight: bold;">#include</span> <span style="color: #5EC4FF;">&lt;</span><span style="color: #539AFC;">stdio.h</span><span style="color: #5EC4FF;">&gt;</span>

<span style="color: #EBBF83;">int</span> <span style="color: #33CED8;">main</span><span style="color: #5EC4FF;">(</span><span style="color: #EBBF83;">int</span> <span style="color: #718CA1;">argc</span>, <span style="color: #EBBF83;">char</span> *<span style="color: #718CA1;">argv</span><span style="color: #E27E8D;">[]</span><span style="color: #5EC4FF;">)</span>
<span style="color: #5EC4FF;">{</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"We"</span><span style="color: #E27E8D;">)</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Didn't"</span><span style="color: #E27E8D;">)</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Start"</span><span style="color: #E27E8D;">)</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"The"</span><span style="color: #E27E8D;">)</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Fire"</span><span style="color: #E27E8D;">)</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Billy"</span><span style="color: #E27E8D;">)</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Joel"</span><span style="color: #E27E8D;">)</span>
  <span style="color: #5EC4FF;">return</span> 0;
<span style="color: #5EC4FF;">}</span>
</pre>
</div>

<p>
Great. We forgot the semicolons, and the <code>\n</code> after each string,
because we're Python developers. The slow way to do it is to go to
every line and manually type in what we need to. If we're the cool
new kids, we'll use multiple cursors&#x2026;oh wait. We can only use
multiple cursors to add semicolons to the ends of the lines, but
the location of the <code>\n</code> is different in every case. Vim macros to
the rescue.
</p>

<p>
A vim macro simply records all keystrokes from the start of
recording to the end and replays them. Let's record a macro <code>a</code>. Hit
<code>qa</code>. Now, <code>02f"i\n&lt;Esc&gt;A;&lt;Esc&gt;0jq</code>.<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> This records the keystrokes
and saves it as macro <code>a</code>. To replay the macro for the remaining 6
lines, run <code>6@a</code>.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #5EC4FF; font-weight: bold;">#include</span> <span style="color: #5EC4FF;">&lt;</span><span style="color: #539AFC;">stdio.h</span><span style="color: #5EC4FF;">&gt;</span>

<span style="color: #EBBF83;">int</span> <span style="color: #33CED8;">main</span><span style="color: #5EC4FF;">(</span><span style="color: #EBBF83;">int</span> <span style="color: #718CA1;">argc</span>, <span style="color: #EBBF83;">char</span> *<span style="color: #718CA1;">argv</span><span style="color: #E27E8D;">[]</span><span style="color: #5EC4FF;">)</span>
<span style="color: #5EC4FF;">{</span>
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"We\n"</span><span style="color: #E27E8D;">)</span>;
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Didn't\n"</span><span style="color: #E27E8D;">)</span>;
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Start\n"</span><span style="color: #E27E8D;">)</span>;
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"The\n"</span><span style="color: #E27E8D;">)</span>;
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Fire\n"</span><span style="color: #E27E8D;">)</span>;
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Billy\n"</span><span style="color: #E27E8D;">)</span>;
  printf<span style="color: #E27E8D;">(</span><span style="color: #539AFC;">"Joel\n"</span><span style="color: #E27E8D;">)</span>;
  <span style="color: #5EC4FF;">return</span> 0;
<span style="color: #5EC4FF;">}</span>
</pre>
</div>

<p>
Note that vim even supports recursive macros. That would work by
first setting <code>a</code> to an empty macro: <code>qaq</code>. Then,
<code>qa02f"i\n&lt;Esc&gt;A;&lt;Esc&gt;0j@aq</code>. A single <code>@a</code> runs this till the
last line of the file (though this isn't what we wanted).
Recursive macros aren't used often, but are fun to write.
</p>
</div>
</div>

<div id="outline-container-orgaf89149" class="outline-4">
<h4 id="orgaf89149"><span class="section-number-4">2.5.3</span> Macros <i>are</i> Registers</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
Macros are stored in registers. Many people don't know that
recording a macro is just writing keystrokes to a register. You
can in fact <code>@</code> any register to interpret its contents as
keystrokes. This means you could copy a vim macro from a website
to your X clipboard and run it directly in vim (<code>@0</code>).
</p>
</div>
</div>

<div id="outline-container-org67fe61b" class="outline-4">
<h4 id="org67fe61b"><span class="section-number-4">2.5.4</span> Rectangular Selection</h4>
<div class="outline-text-4" id="text-2-5-4">
<p>
Here's something the new kids on the block use multiple cursors
for: rectangular selection. If we have the following file:
</p>

<pre class="example">
Dr. John Smith
Mr. Nebhrajani A
Ms. Addams
Lt. James Rhodes
Mr. Walker
</pre>

<p>
And we want to delete those pesky titles, a quick way to do this
in vim is to type <code>C-v</code> to enable rectangular selection, then use
<code>hjkl</code> to select the appropriate rectangle and hit <code>d</code>, resulting
in:
</p>


<div class="figure">
<p><img src="./rec.png" alt="rec.png" />
</p>
</div>

<pre class="example">
John Smith
Nebhrajani A
Addams
James Rhodes
Walker
</pre>
</div>
</div>

<div id="outline-container-orge30d2b1" class="outline-4">
<h4 id="orge30d2b1"><span class="section-number-4">2.5.5</span> Marks</h4>
<div class="outline-text-4" id="text-2-5-5">
<p>
Marks are simple: they let you set a kind of bookmark at a certain
location in a file and jump back to it. Marks are set using <code>ma</code>
and dereferenced using <code>`a</code>. Mark <code>`</code> is also automatically set when
you jump using <code>G</code>, meaning <code>``</code> jumps you back to your old context.
A neat feature not many modern editors have.
</p>
</div>
</div>

<div id="outline-container-orgce1191a" class="outline-4">
<h4 id="orgce1191a"><span class="section-number-4">2.5.6</span> Undo Tree</h4>
<div class="outline-text-4" id="text-2-5-6">
<p>
If vim didn't already have a whole bunch of killer features,
here's yet another: undo trees. Let's say you type the following:
</p>

<pre class="example">
Something something other
</pre>

<p>
Now we undo.
</p>

<pre class="example">
Something something
</pre>

<p>
Then we type:
</p>

<pre class="example">
Something something weird
</pre>

<p>
Undo this again.
</p>

<pre class="example">
Something something
</pre>

<p>
Make an edit:
</p>

<pre class="example">
Something something final
</pre>

<p>
It should be obvious to you that there are three branches of undo
history: the one where we typed <code>other</code>, one with <code>weird</code>, and one
with <code>final</code>. Most editors discard old branches of this tree and
maintain a linear undo history, but this is blatant dishonest:
such an editor is discarding edit history, possibly causing
information loss. Vim's model saves the whole tree, and at nodes
allows you to select which branch you want to explore. Neat.<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup>
</p>
</div>
</div>
</div>

<div id="outline-container-org69ec04c" class="outline-3">
<h3 id="org69ec04c"><span class="section-number-3">2.6</span> Vim Caveats</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Despite vim having absolutely brilliant ideas for raw text editing,
including comfortable, thoughtful key notes, it suffers from
certain flaws. Many of these are due to its running in the
terminal: poor support for Unicode characters, no GUI-like modeline
niceness, etc. Another big issue is the extension language,
Vimscript, which is ugly and hard to use. It makes implementing
modern features like autocompletion and file browsers hard to
implement. Moreover, the plugin API isn't very pretty either. Vim
also really isn't built to do much other than pure text editing.
It's not meant to be very flexible, and to its credit, it does what
it's supposed to fairly well.
</p>

<p>
Of course, vim purists insist that vim is meant to be minimal, a
small tool in the UNIX toolchain.<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup> However, for people who
want more modern IDE-like features in their text editor, vim isn't
the best choice.
</p>

<p>
Now, the vim community is making efforts to fix this: there's a GTK
version of vim, and the <code>neovim</code> project fixes a lot of issues with
vim including its plugin interface, and is a great option if you've
read this far and don't have the energy to read further.
</p>

<p>
Despite vim's problems, it's a useful and extremely powerful
editor. Moreover, it'll be there on any UNIX system you encounter,
so it's worth learning if only for that reason.
</p>
</div>
</div>
</div>

<div id="outline-container-orga795681" class="outline-2">
<h2 id="orga795681"><span class="section-number-2">3</span> Powerful Environment</h2>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
In this post, we focus our attention on text editors rather
than IDEs, although the distinction between the two is often blurred.
I make this choice because Emacs itself is a text editor, and the
IDE-like bits are all custom elisp.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<code>C-</code> is <code>Ctrl-</code>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
Image credit: <a href="https://commons.wikimedia.org/w/index.php?curid=9666341">By Cy21 - Own work, CC BY-SA 3.0</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
Yeah, that looks ugly, so let's break it down. <code>0</code> goes to the
start of the line. <code>2f"</code> finds the second " mark. <code>i\n</code> goes into
insert mode and inserts the newline. <code>&lt;Esc&gt;</code> to go back to normal
mode. <code>A</code> to go to the end of the line and enter insert mode. <code>;</code>
inserts the semicolon. &lt;Esc&gt; to normal mode. Then <code>0j</code> go to the start of the
line and go to the next line. Then <code>q</code> to end the macro. It's simple
once you get used to it.
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
I really wish browser back buttons supported a tree like
approach too. If you know of such a plugin, let me know.
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
We'll argue later about minimalism vs. maximalism in text editors.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<hr><p style="font-size: 75%">Created in GNU <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.3.6).</p>
</div>
</body>
</html>
