<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-05-28 Fri 08:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>~nebhrajani/posts/new-age-software/</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Nebhrajani A.V." />
<html class="sea-theme">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../../stylesheets/hack.css" />
<link rel="stylesheet" href="../../stylesheets/css.css" />
<link rel="stylesheet" href="../../stylesheets/standard.css" />
<link rel="stylesheet" href="../../stylesheets/index.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<nav class="sidebar-nav">
<a class="nav-item" title="" href="https://nebhrajani-a.github.io/">home</a>
<a class="nav-item" title="" href="https://nebhrajani-a.github.io/posts/">posts</a>
<a class="nav-item" title="" href="https://nebhrajani-a.github.io/files/">files</a>
</nav>

<h1 id="title">New Age Software Development</h1>
<div class="post-meta"> <2020-10-22 Thu> - 4 min read
</div>

<div id="outline-container-org396e98b" class="outline-2">
<h2 id="org396e98b"><span class="section-number-2">1</span> UNIX Tools</h2>
<div class="outline-text-2" id="text-1">
<p>
Donald Knuth, demonstrating literate programming, once
wrote a ten-page program to count the \(k\) most
frequently used words in an input file, and print out a sorted list of the
words with their frequencies. Knuth&rsquo;s paper was reviewed
by McIlroy, who added at the end of his review a six
command pipeline (using UNIX tools), that also solves the
problem.
</p>

<div class="org-src-container">
<pre class="src src-sh">tr -cs A-Za-z <span style="color: #539AFC;">'\n'</span> |
tr A-Z a-z |
sort |
uniq -c |
sort -rn |
sed $<span style="color: #5EC4FF;">{</span><span style="color: #718CA1;">1</span><span style="color: #5EC4FF;">}</span>q
</pre>
</div>
<p>
For those unfamiliar with the UNIX command line, this
pipeline takes the input text stream,
transliterates the complement (-c) of the alphabet set to newlines,
and squeezes (-s) multiple newlines. It then &rsquo;pipes&rsquo; this
stream into the next command, which transliterates all
capital letters to lowercase ones. These are then sorted
to bring identical words together, and duplicates removed
using <code>uniq</code>, with a count added (-c). Again
sorted in reverse numeric order, since the first &rsquo;column&rsquo;
of the stream is the frequency. The top \(k\) lines are
then printed using the stream editor (taken as the first
argument, ${1}). This could&rsquo;ve been done
using <code>head</code> as well, but perhaps it wasn&rsquo;t
around at the time.
</p>


<p>
This example perfectly illustrates the power of the UNIX
command line and philosophy. Although Knuth&rsquo;s solution was
more efficient (\(O(n\log{n})\) vs \(O(\log{n})\) IIRC),
the beauty lies in the way UNIX works: it&rsquo;s a set of tiny
programs that don&rsquo;t do much alone, but together are able
to perform complex tasks one would have to write a
monolithic program to solve. This is the right way to
write software: since it does not leave the end user
trapped in the mind and imagination of the developer: the
user can do whatever he wants with a box of tools. This
has an analogue in mechanical work: would you choose one
tool that does a few tasks in a mediocre way, or carry a
toolbox that can do any number of tasks by using the tools
in combination? Yes: modular is better.
</p>
</div>
</div>

<div id="outline-container-org5938cad" class="outline-2">
<h2 id="org5938cad"><span class="section-number-2">2</span> Monolithic Software</h2>
<div class="outline-text-2" id="text-2">
<p>
The software people use today is nothing like the UNIX
shell
(usually <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a>.
It&rsquo;s usually a gigantic program that does the functions of
many smaller programs. A popular example (from a brilliant
essay
called <a href="http://cristal.inria.fr/~weis/info/commandline.html">In The Beginning Was The Command Line</a>, is that of
the program <code>wc</code> being replaced by a feature
in, say, MS Word that counts all the words. In essence,
modern programs accumulate features, combining the
features of more and more smaller programs and integrating
them. This probably started with the Kitchen Sink, Emacs,
but was quickly adopted by many others. Let me be clear.
This approach isn&rsquo;t necessarily wrong or less good: but it
does mean one thing: you&rsquo;ll reach a point where
two <i>huge</i> programs just can&rsquo;t be combined with each
other. Maybe it&rsquo;s because they were built by different
people, or to solve different problems: but they can&rsquo;t
communicate with each other using pipes and text streams
anymore, for instance, Word and \(\mathrm{\LaTeX}\). This
is where the problems begin:
</p>
<ol class="org-ol">
<li>Big programs can&rsquo;t work together neatly. They use
different file formats, they&rsquo;re doing different tasks,
and a huge amount of code has to be written to make
these programs talk to each other.</li>
<li>De-facto standards are set, giving one piece of
software a monopoly. By definition, such software will
be the easiest to use even for a beginner. However,
easy to use tools are seldom the best possible tools
for the job. Consider Microsoft Word. Easy to use,
requires no reading of the manual, but cannot handle
serious writing well at all. Besides, such software
generates monopolies: the 90&rsquo;s Microsoft monopoly
wasn&rsquo;t very long ago.</li>
</ol>


<p>
What does this eventually mean for software as a whole?
It&rsquo;s a net loss for humanity. Instead of using tools of
mathematical precision, we tend to use the only tool we
know how. The law of the instrument plays out, eventually
resulting in nobody but the intellectual &rsquo;elite&rsquo; using the
right tools for the job.
</p>


<p>
I&rsquo;m not sure how software gets away with this. Everywhere
else (think back to car mechanics), eventually, people
learn to use the right tool and adopt it quickly. However,
it seems that this does not hold true for software. Is it
really that hard to read a manual and to spend a few days
learning to use, say, vim? It does pay off in the long
run. Maybe it&rsquo;s human laziness: it&rsquo;s much easier to click
around and guess at how to use software than reading its
manual.
</p>
</div>
</div>

<div id="outline-container-org486da1e" class="outline-2">
<h2 id="org486da1e"><span class="section-number-2">3</span> Conclusion</h2>
<div class="outline-text-2" id="text-3">
<p>
Steve Jobs often touted how people completely unfamiliar
with computers could quickly use iOS without much help due
to its simple design. He was right: using iPhones is a lot
easier than using Linux, and requires far less training.
Maybe that&rsquo;s a good thing: but it over-panders to a class
of users having no prior experience with computers:
primarily children and grandparents. However, there is an
increasingly large number of people today using crappy
tools, despite having a fair amount of computer literacy:
the secretaries, the administrators, the government, the
police. That&rsquo;s a potential market to tap into.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr><p style="font-size: 75%">Created in GNU <a href="https://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="https://orgmode.org">Org</a> mode 9.3.6).</p>
</div>
</body>
</html>
