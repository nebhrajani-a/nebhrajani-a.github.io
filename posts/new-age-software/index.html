<!DOCTYPE html>
<html class="sea-theme"><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">


    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>/nebhrajani/posts/new-age-software</title>

    <link rel="stylesheet" href="../../stylesheets/hack.css">
    <link rel="stylesheet" href="../../stylesheets/standard.css">
    <link href="../../stylesheets/css.css" rel="stylesheet">

    <link rel="stylesheet" href="../../stylesheets/index.css">

    <link rel="canonical" href="https://nebhrajani-a.github.io/posts/">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <span class="header-path">

      <a href="https://nebhrajani-a.github.io/">/nebhrajani</a><a href="https://nebhrajani-a.github.io/posts/">/posts/</a><a href="https://nebhrajani-a.github.io/posts/new-age-software/">new-age-software</a>

    </span>
    <style>
      pre {
      width: 99%;
      overflow: auto;
      padding: 0.2cm;
      border:1px solid;
      }
    </style>
    <!--  ──────────────────────── Use hilite.me ─────────────────────── -->
    <!--  ──────────── This doesn't seem to work anymore. ──────────── -->
    <style>
      p {
      text-align: justify;
      text-justify: inter-word;
      }
      blockquote{
      font-size: 150%;
      }
    </style>
    <section id="main">
      <h1 id="title">New Age Software Development</h1>
      <div class="post-meta">Thu, Oct 22, 2020 - ? min </div>

      <div>
	<article id="content">
          <p>
            In recent years, people have grown into the technology they see
            around them. This isn't to say that this wasn't the case before, but
            simply that a far greater number of people are familiar and
            comfortable with technology than ever before. A large part of this
            credit goes to mobile device makers: in particular, Apple Inc. and
            Google's Android. Nearly 60% of the world's population has an
            Internet connection, with the rest quickly catching up. This has
            meant a nearly insatiable market for flashy new software and
            hardware. Such a market seems to only have grown with the COVID-19
            worldwide quarantine. This is in stark contrast to, say, the 70s,
            when UNIX was primarily distributed to universities and used for
            research. This article is in part a trip down the memory lane, but
            it is also a lament for days when software was light and powerful.
          </p>
          <h2>Down The Memory Lane</h2>
          <p>
            Now, I'm an early 2000s kid. I saw Club Penguin come and go, and
            pretty much saw a lot of technology grow up with myself. However, I
            never saw things like a computer without a GUI, classical
            telephones, and so on. My childhood was an interesting one,
            especially with watching the advent of the Internet: but never
            really being warned about how risky it could be. It was also
            interesting watching the pre-iPhone state of the handheld computer
            market: including Palm's and Nokia's interesting, but ultimately
            doomed concepts. I digress, but the point here is that a majority of
            the people my age came into a magical world of technology, seemingly
            detached from the black-colored terminal window I'd see my parents
            typing into for a majority of their workday.
          </p>
          <h3>Tools, Drag-N-Drop, and Hating It All</h3>
          <p>
            Growing up around GUIs meant that nearly every tool beginners around
            me operated had their own pretty mouse-based interface. These tools
            came and went nearly as fast as the days: from PowerPoint to Prezi
            to Canva, all these tools had one thing in common: they were
            beginner friendly. This isn't to say they were poor tools: many of
            them still exist today, and I
            hear <a href="https://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf">PowerPoint
              is Turing complete.</a> A similar phenomenon was going on with text
            editors and developer tools: people were (finally) shifting away
            from the ancient vi(m) and Emacs to Eclipse, TextMate, then Sublime,
            and all sorts of other IDEs. The golden age of computing had
            arrived: everybody was a computing genius with a mouse, a pretty
            interface, and a snappy wrist to drag-and-drop.
          </p>
          <p>
            Can you blame me for getting swept away? For years, from when I
            first got my hands on my first computer (2006, I think), to 2019, I
            participated in the tools race as much as any young person could do.
            I jumped from BASIC to LOGO to Scratch, from MS Word to Prezi to
            Canva, from SuperTux (Super Mario clone) to Asphalt 8. At some
            point, however, this began to feel...forced. More inefficient than
            forced, of course, but I got disillusioned with the software I saw
            around me. Was this really how life in computing was? Bending over
            backwards to shift to the latest tool that has X feature over the
            previous one, ever in pursuit of a mythical perfect workflow? Is
            this how my parents made a living? Was this how the pros do it? And
            at some level, I began to resent it all. In 2017, I think, I
            attended an internship over a summer at Infosys Ltd., a widely
            respected IT services firm. Everybody wanted (wants?) a job there,
            or so I was told. Going there for a few weeks and seeing the
            exhausted faces of the employees, while a bearded, middle aged man
            tried to teach me how to link an SQL database to a Java program
            using Eclipse killed my interest in software for a long
            while, and my interests went elsewhere.
          </p>
          <h3>StackExchange and \(\mathrm{\TeX}\)</h3>
          <p>
            My interests having shifted to physics and mathematics, I
            went out to the Internet in my free time to indulge in
            them. I reached where everybody reaches when they need
            answers: <a href="https://www.stackexchange.com">StackExchange.</a>
            While writing answers and asking questions for the
            community, I fell in love with what everybody called
            MathJax: a JavaScript library for getting beautiful math
            on the site. Its system for typesetting equations was the
            prettiest I'd ever seen: they looked just like textbooks
            and were vector images. They looked something like this:
            \[W=\int_{r_1}^{r_2} \frac{q_1 q_2}{4\pi \varepsilon_0
            r^2} dr\] The language for formatting these was infinitely
            nicer to work with than Microsoft's toolbox for writing
            equations, which is what I'd used my whole life. It looked
            like this:
            <cite>
              $W=\int_{r_1}^{r_2} \frac{q_1 q_2}{4\pi \varepsilon_0
              r^2} dr$.
            </cite>
            Reading more about MathJax, I realised the syntax is
            actually based on a program from 1991 called
            \(\mathrm{\TeX}\), which was also used to format nearly
            every journal article I'd read. No wonder they all look so
            similar. Predictably, this led to me exploring
            \(\mathrm{\LaTeX}\), Linux, GNU, Emacs, vi...and,
            realising that there's a world of computer science that
            wasn't all about IDEs and fancy GUI tools. Although seen
            as boring and old school, there's a certain charm to old
            software and tools that new ones seem to have completely
            lost.
          </p>
          <h2>The Charm of Eight Megabytes</h2>
          <p>
            Now, I'm probably the least qualified person to talk about
            old-age software: I'm a young(ish) kid, but seeing the
            efficiency and elegance of old software is, well,
            life-altering. Till the late 90's, programming a computer
            was an exercise in mathematics: in the sense that every
            program was written with mathematical elegance. This is
            not to say that there aren't any programs today that are
            written this way, or that there weren't any then that were
            written poorly, but simply that because of a lack of
            resources, computer scientists had to be frugal and write
            light programs. Compilers can only optimize so much:
            writing light and powerful code was the gold standard.
            This also meant that most work wasn't done using a GUI,
            but via text streams. This led to the creation of a
            brilliant system of its own right: UNIX, with a clever but
            simple core philosophy:
            <cite>
              each program should do one thing, and do it well.
            </cite> Doug McIlroy, the creator of the pipe (|) also
            added his own, about usefully using STDIN and STDOUT, and
            handling text streams. Such a philosophy may seem
            simplistic and obvious, but it is the holy grail of
            writing good software.
          </p>
          <h3>UNIX Tools</h3>
          <p>
            Donald Knuth, demonstrating literate programming, once
            wrote a ten-page program to count the \(k\) most
            frequently used words in an input file, and print out a sorted list of the
            words with their frequencies. Knuth's paper was reviewed
            by McIlroy, who added at the end of his review a six
            command pipeline (using UNIX tools), that also solves the
            problem.
          </p>
            <blockquote style="font-size:14px">
              tr -cs A-Za-z '\n' |
              tr A-Z a-z |
              sort |
              uniq -c |
              sort -rn |
              sed ${1}q
            </blockquote>
          <p>
            For those unfamiliar with the UNIX command line, this
            pipeline takes the input text stream,
            transliterates the complement (-c) of the alphabet set to newlines,
            and squeezes (-s) multiple newlines. It then 'pipes' this
            stream into the next command, which transliterates all
            capital letters to lowercase ones. These are then sorted
            to bring identical words together, and duplicates removed
            using <code>uniq</code>, with a count added (-c). Again
            sorted in reverse numeric order, since the first 'column'
            of the stream is the frequency. The top \(k\) lines are
            then printed using the stream editor (taken as the first
            argument, ${1}). This could've been done
            using <code>head</code> as well, but perhaps it wasn't
            around at the time.
          </p>
          <p>
            This example perfectly illustrates the power of the UNIX
            command line and philosophy. Although Knuth's solution was
            more efficient (\(O(n\log{n})\) vs \(O(\log{n})\) IIRC),
            the beauty lies in the way UNIX works: it's a set of tiny
            programs that don't do much alone, but together are able
            to perform complex tasks one would have to write a
            monolithic program to solve. This is the right way to
            write software: since it does not leave the end user
            trapped in the mind and imagination of the developer: the
            user can do whatever he wants with a box of tools. This
            has an analogue in mechanical work: would you choose one
            tool that does a few tasks in a mediocre way, or carry a
            toolbox that can do any number of tasks by using the tools
            in combination? Yes: modular is better.
          </p>
          <h3>Monolithic Software</h3>
          <p>
            The software people use today is nothing like the UNIX
            shell
            (usually <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)">bash</a>).
            It's usually a gigantic program that does the functions of
            many smaller programs. A popular example (from a brilliant
            essay
            called <cite><a href="http://cristal.inria.fr/~weis/info/commandline.html">In
            The Beginning Was The Command Line</a></cite>, is that of
            the program <code>wc</code> being replaced by a feature
            in, say, MS Word that counts all the words. In essence,
            modern programs accumulate features, combining the
            features of more and more smaller programs and integrating
            them. This probably started with the Kitchen Sink, Emacs,
            but was quickly adopted by many others. Let me be clear.
            This approach isn't necessarily wrong or less good: but it
            does mean one thing: you'll reach a point where
            two <b>huge</b> programs just can't be combined into each
            other. Maybe it's because they were built by different
            people, or to solve different problems, but they can't
            communicate with each other using pipes and text streams
            anymore, for instance, Word and Excel, or Word and
            LibreOffice. This is where two problems begin:
            <ol>
              <li>Big programs can't work together neatly. They use
              different file formats by this point, they're doing
              different tasks, and a huge amount of code has to be
              written to make these programs talk to each other.</li>
              <li>Alternatives come up often. It isn't hard to combine
              simple small programs into a larger one, and pretty soon
              a competitor in the same space comes up with a product
              that has the <i>one</i> missing feature (small program)
              the other didn't. Now you're back to problem (1), since
              some users will use someone else's program, or will
              want to use both, or steal the feature.</li>
            </ol>
          </p>
          <p>
            This feature race is meaningless, since it means every
            program
            will <a href="https://en.wikipedia.org/wiki/Feature_creep">creep
            features</a> until it's the kitchen sink. This also makes
            programs harder to use, but most importantly, harder to
            break out of. On the other hand, because everything is
            integrated, these programs can look pretty and appear
            simple to use
          </p>

	</article>
      </div>
    </section>
    <!-- <aside id="meta" style="display: fixed;top:100px;right: 0"> -->
    <!-- 	<div> -->

    <!-- 		<a class="previous" href="https://ryanfaulhaber.com/posts/fp-lessons/"> Lessons Learned from Functional Programming</a> -->


    <!-- 	</div> -->
    <!-- </aside> -->




    <footer id="footer">
      <p id="copyright">

      </p>
    </footer>


</body></html>
